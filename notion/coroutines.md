# Coroutines

**Сопрограмма** — это экземпляр приостанавливаемых вычислений. Концептуально он похож на поток в том смысле, что для запуска требуется блок кода, который работает одновременно с остальным кодом. Однако сопрограмма не привязана ни к какому конкретному потоку. Он может приостановить выполнение в одном потоке и возобновить его в другом.

Сопрограммы можно рассматривать как *легковесные потоки*, но есть ряд важных отличий, которые сильно отличают их реальное использование от потоков.
В первую очередь, потоки применяются для организации многозадачности, корутины же предоставляют лишь асинхронные операции, но не выполняются параллельно (хоть в Kotlin JVM это возможно параллельность не является частью понятия корутин).

# Преимущество корутин над потоками:

- легкость переключения между потоками (т.к. не нужно никаких системных вызов или каких-либо блокирующих операций). Поэтому их называют легковесными потоками.
- Не требуют никакой поддержки со стороны ОС (позволяет легко добавить их в любой язык программирования).

# Асинхронность vs Параллельность

**Асинхронность** - концепция программирования, в которой события происходят независимо от главного потока и способ взаимодействия не является последовательным, а происходит через колбеки. (Яркий пример mainThread в Android с Handler-ом и Looper-ом)

или 

концепция программирования, которая заключается в том, что результат выполнения функции доступен не сразу, а через некоторое время в виде некоторого асинхронного (нарушающего обычный порядок выполнения) вызова.

 **Параллельность** - тип вычислений, когда множество операций выполняется одновременно. Современные процессоры способствуют этому т.к. имеют множество ядер.

# Корутины в Kotlin

Киллер фичей была возможность **писать асинхронный код в синхронном стиле.**
Для поддержки корутин в котлине было добавлено одно ключевое слово ***suspend*** (рус. приостанавить)

```kotlin
suspend fun doWork() {
// Здесь будет долгая работа
}

//decompiled
public final Object doWork(@NotNull Continuation<Unit> $completion)
```

Такая функция не может быть вызвана из обычной функции, т.к. она возвращает свой ответ асинхронно. Suspend-функцию можно вызвать из другой suspend-функции, либо из корутины, которая создается из корутин-билдеров.
***Continuation*** можно рассматривать как callback, который будет вызван по окончании выполнения тела функции.
Kotlin-копилятор преобразует весь код корутин (suspend-лямбд если быть точнее) в state-машину - длинный цикл(??) switch-case, где каждый case соответствует какому-то вызову suspend-функции. (Во что компилируется можно посмотреть тут [customLaunch](https://github.com/ZharovVV/KotlinSandbox/blob/master/src/main/kotlin/com/github/zharovvv/coroutines/CoroutinesWorkDescription.kt)) Такой подход позволяет генерировать меньше кода и классов, а самое главное - создавать меньше объектов в памяти во время работы приложения.
В стандартную библиотеку Kotlin были добавлены лишь самые основные функции для организации работы корутин. Все основные возможности корутин были добавлены через отдельную бибилиотеку **kotlinx.coroutines**.

# Coroutines vs Threads

Корутины используют только заданные пулы потоков. И используют их умно. Ключевое слово suspend приостанавливает работу корутины, продолжение работы корутины может произойти на любом потоке из ***CoroutineDispatcher***-а, заданного в рамках этой корутины.

**Корутина может выполняться в нескольких потоках**. В примере ниже нет гарантии работы в одном потоке.

```kotlin
val lock = ...
lock.lock() //захват блокировки
doSomething() //suspend функция
lock.unlock() //снятие блокировки
```

> Не стоит использовать java апи синхронизации в корутинах.
> 

Каждая корутина привязана к времени жизни ***CoroutineScope***. Любая запускаемая корутина привязана к ***CoroutineScope***, который и описывает этот некий жизненный цикл.
Состояние корутины (например *isActive*) проверяется перед тем, как продолжить её выполнение после прерывания. Т.е. перед вызовом любой suspend функции корутина **может быть** остановлена.

# Примеры некоторых функций

- ***launch*** - это *builder* сопрограмм. Он запускает новую сопрограмму одновременно с остальным кодом, которая продолжает работать независимо.
- ***delay*** - это специальная функция приостановки. Он приостанавливает сопрограмму на определенное время. Приостановка сопрограммы не блокирует базовый поток, но позволяет запускать другие сопрограммы и использовать базовый поток для своего кода.
- ***runBlocking*** - также является *builder*-ом сопрограмм, который соединяет между собой обычный мир без сопрограмм *fun main()* и код с сопрограммами внутри *runBlocking { ... }* фигурных скобок. Это выделяется в IDE this: CoroutineScope подсказкой сразу после runBlocking открывающей фигурной скобки. Если вы удалите или забудете runBlocking в этом коде, вы получите ошибку при вызове запуска launch, так как он объявлен только в CoroutineScope : *Unresolved reference: launch.* Название *runBlocking* означает, что выполняющий его поток (в данном случае — основной поток) блокируется на время вызова, пока все сопрограммы внутри *runBlocking { ... }* не завершат свое выполнение. Вы часто будете видеть *runBlocking* такое использование на самом верхнем уровне приложения и довольно редко внутри реального кода, поскольку потоки являются дорогостоящими ресурсами, и их блокировка неэффективна и часто нежелательна.

# Структурированный параллелизм (Structured concurrency)

[Реализация структурированной конкурентности в Java и Kotlin](https://medium.com/nuances-of-programming/%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B9-%D0%BA%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%B2-java-%D0%B8-kotlin-f2e677cb7641)

В общем две главные цели Структурированного параллелизма звучат так:

- предоставление возможности написания понятного конкурентного (параллельного) кода
- предотвращение утечек потоков

> Структурированный парраллелизм в корутинах достигается за счет ***CoroutineScope***.
> 

Сопрограммы следуют принципу структурированного параллелизма, что означает, что новые сопрограммы могут запускаться только в определенной ***CoroutineScope***, которая ограничивает время жизни сопрограммы. В приведенном выше примере показано, что *runBlocking* устанавливает соответствующую область действия, и поэтому предыдущий пример ждет, пока World! не будет напечатано после секундной задержки, и только после этого завершается.
В реальном приложении вы будете запускать множество сопрограмм. Структурированный параллелизм гарантирует, что они не будут потеряны и не будут утечек. Внешняя область не может завершиться, пока не будут завершены все ее дочерние сопрограммы. Структурированный параллелизм также гарантирует, что обо всех ошибках в коде сообщается должным образом, и они никогда не теряются.

[7 common mistakes you might be making when using Kotlin Coroutines | Lukas Lechner](https://www.lukaslechner.com/7-common-mistakes-you-might-be-making-when-using-kotlin-coroutines/)

[CoroutineContext](coroutines/coroutine_context.md)

[CoroutineScope](coroutines/coroutine_scope.md)

[Обработка ошибок в корутинах](coroutines/error_hadling.md)

[`*Channel*`](coroutines/channel.md)

[Синхронизация в корутинах](coroutines/synchronization.md)

[Flow](coroutines/flow.md)