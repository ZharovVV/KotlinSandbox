# Многопоточность

### Thread. Прерывание потока.

***Формы многозадачности***:

- на основе процессов
- на основе потоков

> **Процесс** - это экземпляр выполняющейся программы, простыми словами при запуске любой программы на вашем компьютере, вы порождаете процесс. Он имеет свое собственное адресное пространство памяти и один или несколько потоков.
> 

*Процессы могут общаться между собой через **межпроцессное взаимодействие** (inter-process communication, **IPC**).*

> **Поток** - это последовательность инструкций, выполняющаяся внутри процесса. Потоки делят адресное пространство памяти процесса, что позволяет им работать параллельно.
> 

**Корректная обработка InterruptedException:**

```kotlin
fun main() {
    val mainThread = Thread.currentThread()
    println(mainThread.stackTrace.forEach(::println))
    val thread1 = Thread {
        try {
            Thread.sleep(3000L)
        } catch (e: InterruptedException) {
            //Корректная обработка InterruptedException
            //При перехвате исключения InterruptedException в catch статус потока автоматически сбрасывается
            // и Thread.currentThread().isInterrupted() вернет false.
            //Поэтому мы повторно устанавливаем флаг потока, сигнализирующий о прерывании.
            Thread.currentThread().interrupt()
            /* Прерывание потока осуществляется при помощи метода Thread.interrupt().
             Существует два способа которыми JVM уведомляет поток о том, что его прерывают.
             Первый — это собственно InterruptedException.
             Второй — это флаг потока INTERRUPT, который может быть получен при помощи метода Thread.isInterrupted().
             Игнорирование второго метода сигнализирования о прерывании и является типичной ошибкой.*/
        }
    }
		thread1.start()
		thread1.join()
}
```

### volatile

`volatile` - ключевое слово для работы с многопоточностью.

В Kotlin используется соответствующая аннотация.

```kotlin
@Volatile
var volatileVar: String = "test"
```

> В Kotlin можно использовать только с `var`.
> 

Для чего нужно:

- **Чтение и запись в это поле являются атомарными.**

> Это применение актуально только для 64 битных (8 байтных) `long` и `double` в 32-битных платформах, для которых не реализована атомарность чтения/записи 64-битных переменных.
> 

- **Записи всегда становятся видимыми для других потоков.**

> В процессе работы многопоточного приложения разные потоки могут кэшировать значения переменных (*в кэш процессора, например*).
Возможна ситуация, когда один поток изменил значение переменной, а второй не увидел этого изменения, потому что работал со своей, кэшированной копией переменной. При использовании ключевого слова `volatile` JVM не будет помещать  переменную в кэш (процессора), а поместит переменную в общедоступный для всех потоков RAM.
> 

### synchronized

`synchronized` - ключевое слово в Java, которое гарантирует, что в данный момент времени только один поток имеет доступ к блоку кода или методу, помеченному как `synchronized`. Используется для обеспечения контроля доступа к общим ресурсам в многопоточной среде.

**Принцип работы**

1. Перед входом потока в блок синхронизации выполняется проверка, что **монитор** синхронизируемого объекта не заблокирован.
2. Если **монитор объекта не заблокирован** - то поток выполняет код в блоке
синхронизации, при этом завладевая монитором синхронизируемого объекта.
3. После выполнения кода в блоке поток выходит из монитора синхронизируемого объекта.
4. Если **монитор объекта заблокирован** - то поток будет приостановлен до тех пор, пока поток, владеющий монитором синхронизируемого объекта, не выйдет из монитора.

> В виде оператора синхронизируемый объект предается в явном виде.
В виде модификатора нестатического метода используется - `this`.
В виде модификатора статического метода - `.class` текущего класса.
> 

[Intrinsic Locks and Synchronization (The Java™ Tutorials >        
            Essential Java Classes > Concurrency)](https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html)

В Kotlin используется аннотация и соответствующая inline-функция:

```kotlin
@Synchronized
fun doTask() {
	...
}

fun doTask2() {
	synchronized(lock = this) {
		...
  }
}
```

> Блок `synchronized` также необходим для использования методов [wait, notify, notifyAll](https://itsobes.ru/JavaSobes/wait-notify-notifyall).
> 

### wait, notify, notifyAll

Чтобы вызывать эти методы у объекта, необходимо чтобы был захвачен его монитор (т.е. нужно быть внутри `synchronized`-блока на этом объекте). В противном случае будет выброшено `IllegalMonitorStateException`. Так что для полного ответа нужно понимать, как работает monitor lock (блок synchronized).

Вызов `wait` тормозит текущий поток на ожидание на этом объекте и отпускает его монитор. Исполнение продолжится, когда другой поток вызовет `notify` и отпустит блокировку монитора. Если на объекте ожидают несколько потоков, `notify` разбудит один случайный, `notifyAll` - все сразу.

В теории, ожидание `wait` может быть прервано без вызова `notify`, по желанию JVM (spurious wakeup). На практике это бывает крайне редко, но нужно страховаться и после вызова `wait` добавлять дополнительную проверку условия завершения ожидания.

```kotlin
internal class ProducerConsumer<T> : Object() {

    private val queue: Deque<T> = ArrayDeque()

    @Synchronized
    fun produce(value: T) {
        while (queue.size == BUFFER_MAX_SIZE) {
            wait()
        }
        queue.add(value)
        notify()
    }

    @Synchronized
    fun consume(): T {
        while (queue.size == 0) {
            wait()
        }
        val result = queue.remove()
        notify()
        return result
    }

    private companion object {
        const val BUFFER_MAX_SIZE = 42
    }
}
```

### Atomic

[Как устроены атомики? – Java Interview Review](https://itsobes.ru/JavaSobes/kak-ustroeny-atomiki/)

[Оптимистические и Пессимистические Блокировки](https://jaitl.pro/russian/2021/06/10/optimistic_pessimistic_locking/)

**Happens-before** - это концепция в Java Memory Model, которая определяет отношения порядка между операциями чтения и записи в многопоточном приложении. Happens-before гарантирует, что если операция A happens-before операции B, то любое изменение значения, выполненное в операции A, будет видно операции B.

### Lock

Lock - высокоуровневая альтернатива блоку synchronized.

[Зачем выбирать ReentrantLock вместо synchronized? – Java Interview Review](https://itsobes.ru/JavaSobes/zachem-vybirat-reentrantlock-vmesto-synchronized/)

[Как использовать ReadWriteLock? – Java Interview Review](https://itsobes.ru/JavaSobes/kak-ispolzovat-readwritelock/)

### Executor

### Высокоуровневые примитивы синхронизации из пакета concurrent