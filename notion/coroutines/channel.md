# Channel

Для передачи значений между корутинами мы можем использовать **async-await**, но они позволяют работать лишь с одним значением. Когда нужно работать с несколькими, нужно использовать `Channel` и `Flow`.

# Что такое Channel?

Каналы это концепт, схожий с `BlockingQueue` из Java.

> *Немного про BlockingQueue:*
`BlockingQueue` - это очередь Queue со следующими дополнениями:
- Блокирующая операция take() - берет следующий элемент, если же очередь пустая - блокирует выполнение до появления элемента (до момента, когда перестанет быть пустой)
- Блокирующая операция put(E e) - помещает элемент в очередь, если очередь заполнена - блокирует выполнение до освобождения места в очереди и успешного помещения в нее нового элемента.
> 

Ключевая разница - то что вместо блокирующих потоков операций, `Channel` построены на основе корутин и поэтому используют прерывания. В основном используются два основных метода:

- `Channel.send` - для отправки значений в канал
- `Channel.receive` - для получения значений из канала Получить значения из канала можно не только с помощью `Channel.receive`, но и просто с помощью цикла итерировать по нему (по каналу).

`send` и `receive` - это suspend-функции, но с каналами можно также работать и обычными способами, используя функции:

- `Channel.trySend`
- `Channel.tryReceive`

Эти методы возвращают value class ChannelResult, у которого есть методы для проверки статуса выполнения операции:

- `ChannelResult.isSuccess` - получилось отправить/получить данные
- `ChannelResult.isFailure` - произошла неуспешная операция, но это не означает, что канал закрыт или неисправен. (Например если была попытка отправить значение в заполненный канал.)
- `ChannelResult.isClosed` - канал был закрыт

# Закрытие Channel

По умолчанию канал будет работать до вызова функции `Channel.close`. Под капотом происходит отправка специального значения для индикации того, что в канале больше ничего не будет. При попытке считать значение из закрытого канала будет выброшено исключение. Вы можете проверить доступен ли канал на получение/отправку данных с помощью функций `Channel.isClosedForReceive` и `Channel.isClosedForSend`.

Одновременно у канала может быть больше одного *получателя*, так и больше одного *отправщика*. Каналы рассчитаны на работу с несколькими корутинами.

Важно помнить, что channel может приводить к приостановке корутины, пока он не сможет обработать значение на отправку или получение. Соответственно если есть такое прерывание - оно будет останавливать корутину. Чтобы этого не происходило нужно помнить, что channel, когда он больше не нужен - обязательно нужно останавливать и обрабатывать потенциальную ошибку, которая может произойти в `Channel.send` или `Channel.receive`. (см. пример [badExample](https://github.com/ZharovVV/KotlinSandbox/blob/master/src/main/kotlin/com/github/zharovvv/coroutines/lesson5/ChannelExample.kt))

# Операторы Channel в ранних версиях kotlinx.coroutines

В ранних версиях было множество операторов, для модификации потока данных. Однако с появлением `Flow` эта возможность была убрана, и каналы остались только для своей непосредственной цели: ***коммуникация между несколькими корутинами.*** Хотите работать с реактивными потоками данных - используйте `Flow`.

# Channel без буфера

По умолчанию у каналов нет буфера (используется `capacity = RENDEZVOUS` (т.е. 0)). Получается, что при вызове `SendChannel.send` он (вызов) каждый раз будет приостановлен и не сможет отправить значение получателю. Должно состояться некое "свидание" отправителя с получателем.
Стандартные размеры буфера:

- `Channel.RENDEZVOUS` - без буфера. Размер для любого Channel по умолчанию.
- `Channel.CONFLATED` - Размер буфера - 1. Хранит только последнее полученное значение, а предыдущее удаляется. **Выбирать политику переполнения буфера при таком типе capacity мы не можем**.
- `Channel.BUFFERED` - Задает стандартный размер буфера, который определен в свойствах окружения (по умолчанию это 64)
- `Channel.UNLIMITED` - Максимально возможный размер буфера - `Int.MAX_VALUE`.

Политики поведения при переполнении буфера:

- `BufferOverflow.SUSPEND` - корутина будет приостановлена, если принять значение некому, а буфер переполнен или отсутствует. **Политика по умолчанию.**
- `BufferOverflow.DROP_OLDEST` - Удаляет самые старые значения в буфере при его переполнении. Вызов `send` никогда не приостановит корутину, а `trySend` всегда успешно выполнится, при условии наличия буфера в `Channel`.
- `BufferOverflow.DROP_LATEST` - Удаляет самые новые значения в буфере при его переполнении.

Логично, что не все политики поведения при переполнении буфера могут быть использованы с любым размером буфера.

# `actor` & `produce`

Зачастую, вам не придется в коде использовать `Channel(...)` (создавать его явно). Вы встретитесь с билдерами `CoroutineScope.produce(...)` и `CoroutineScope.actor(…)`, которые возвращают специальные каналы: `ReceiveChannel` и `SendChannel` соответственно.
`produce` нужен для генерации конечных или бесконечных потоков значений. 

`actor` используется для получения значений извне и для их упорядоченной обработки. (Они очень пригодятся для синхронизации работы нескольких корутин.)

# `Channel` vs `Flow`

Каналы позволяют получать и передавать значения извне, а также обеспечивают работу с несколькими корутинами одновременно и делают это безопасно. `Flow` же служат простым горячим потоком данных (речь о замене некоторых Channel на специальные Flow), которые за счет других требований имеют производительность выше и более простое API. Также каналы используются для создания некоторых операторов `Flow` и обмена данными между несколькими корутинами.