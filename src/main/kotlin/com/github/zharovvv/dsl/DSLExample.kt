package com.github.zharovvv.dsl


/**
 * # DSL (Domain-Specific-Languages) - Предметно-ориентированные языки
 *
 * __Предметно-ориентированные языки__ ориентированы на решение задач из одной конкретной _предметной области_ и не
 * обладают средствами для решения любых других задач.
 * Примерами DSL являются SQL, регулярные выражения. Они прекрасно приспособлены для решения узкого круга задач,
 * однако на них не получится написать целое приложение. Заметим, как в этих языках увеличивается
 * эффективность в достижении цели за счет ограничения их технической возможности.
 *
 * Противоположность DSL - __языки общего назначения__.
 *
 * Важная особенность DSL - его стремление к __декларативному синтаксису__. Языки общего назначения в большинстве своем
 * __императивные__. Императивный язык описывает последовательность действий, которые требуется выполнить для завершения
 * операции. Декларативный язык описывает желаемый результат, оставляя детали его получения на усмотрение движка,
 * который интерпретирует код на этом языке.
 * Важный недостаток DSL - его трудно встраивать в приложения, написанные на языках общего назначения. Чтобы решить эту
 * проблему и сохранить основные преимущества DSL была предложена идея __внутренних предметно-ориентированных языков__.
 *
 * ## Внутренние DSL
 * В противоположность _внешним DSL_, обладающих собственным синтаксисом, внутренние DSL - это часть программы, написанная
 * на языке общего назначения и имеющая точно такой же синтаксис. То есть внутренний DSL нельзя считать полностью независимым
 * языком - скорее, это иной способ использования основного языка с сохранением преимуществ, присущих предметно-ориентированным
 * языкам.
 *
 * Инструментами для создания внутреннего DSL в Kotlin являются лямбда-выражения с получателем и соглашения invoke.
 */
fun main() {
    val string = "1"
    val screen =
        Screen {
            header {
                title = "Header"
                text = "header_text"
            }
            widgets {
                widget {
                    title = "Widget1"
                    text = "text_widget_1"
                    properties = mutableMapOf("2" to "3")
                }
                widget {
                    title = "Widget2"
                    text = "text_widget_2"
                }
                widget(additionCondition = string == "2") {
                    title = "Widget3"
                    text = "text_widget_3"
                }
            }
            footer {
                title = "Footer"
                text = "text_footer"
            }
        }
    println(screen)

    ultraFun { int1, int2 ->
        println(this + int1 + int2) //string12
    }
}

fun ultraFun(initBlock: String.(int1: Int, int2: Int) -> Unit) {
    val string = "string"
    val int1 = 1
    val int2 = 2
    string.initBlock(int1, int2)
}