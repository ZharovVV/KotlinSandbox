package com.github.zharovvv.coroutines

import kotlinx.coroutines.*

/**
 * # Coroutines (Сопрограммы)
 * __Сопрограмма__ — это экземпляр приостанавливаемых вычислений.
 * Концептуально он похож на поток в том смысле, что для запуска требуется блок кода,
 * который работает одновременно с остальным кодом.
 * Однако сопрограмма не привязана ни к какому конкретному потоку.
 * Он может приостановить выполнение в одном потоке и возобновить его в другом.
 *
 * Сопрограммы можно рассматривать как __легковесные потоки__,
 * но есть ряд важных отличий, которые сильно отличают их реальное использование от потоков.
 *
 * * [launch] - это builder сопрограмм.
 * Он запускает новую сопрограмму одновременно с остальным кодом, которая продолжает работать независимо.
 *
 * * [delay] - это специальная функция приостановки.
 * Он приостанавливает сопрограмму на определенное время.
 * Приостановка сопрограммы не блокирует базовый поток, но позволяет запускать другие сопрограммы
 * и использовать базовый поток для своего кода.
 *
 * * [runBlocking] - также является builder-ом сопрограмм,
 * который соединяет между собой обычный мир без сопрограмм _fun main()_
 * и код с сопрограммами внутри _runBlocking { ... }_ фигурных скобок.
 * Это выделяется в IDE _this: CoroutineScope_ подсказкой сразу после runBlocking открывающей фигурной скобки.
 * Если вы удалите или забудете runBlocking в этом коде, вы получите ошибку при вызове запуска launch,
 * так как он объявлен только в CoroutineScope :
 * ```
 * Unresolved reference: launch
 * ```
 * Название runBlocking означает, что выполняющий его поток (в данном случае — основной поток)
 * блокируется на время вызова, пока все сопрограммы внутри runBlocking { ... } не завершат свое выполнение.
 * Вы часто будете видеть runBlocking такое использование на самом верхнем уровне приложения
 * и довольно редко внутри реального кода, поскольку потоки являются дорогостоящими ресурсами,
 * и их блокировка неэффективна и часто нежелательна.
 *
 * ##
 * ## Структурированный параллелизм (Structured concurrency)
 * Сопрограммы следуют принципу структурированного параллелизма,
 * что означает, что новые сопрограммы могут запускаться только в определенной CoroutineScope,
 * которая ограничивает время жизни сопрограммы.
 * В приведенном выше примере показано, что runBlocking устанавливает соответствующую область действия,
 * и поэтому предыдущий пример ждет, пока World! не будет напечатано после секундной задержки,
 * и только после этого завершается.
 *
 * В реальном приложении вы будете запускать множество сопрограмм.
 * Структурированный параллелизм гарантирует, что они не будут потеряны и не будут утечек.
 * Внешняя область не может завершиться, пока не будут завершены все ее дочерние сопрограммы.
 * Структурированный параллелизм также гарантирует, что обо всех ошибках в коде сообщается должным образом,
 * и они никогда не теряются.
 */
fun main() {
    //Блокирует текущий поток (до тех пор пока все сопрограммы внутри блока runBlocking не будут выполнены)
    runBlocking {
        //val coroutineScope: CoroutineScope = this
        launch { //is the same coroutineScope.launch {...}
            println("launch 1st coroutine")
            delay(timeMillis = 1000)
            println("World!")
            println("finish 1st coroutine")
        }
        launch {
            println("launch 2nd coroutine")
            suspendFun()
            println("finish 2nd coroutine")
        }
        //
        coroutineScope {
            launch {
                println("launch 3rd coroutine")
                delay(timeMillis = 800)
                println("invoke CoroutineScope")
                println("finish 3rd coroutine")
            }
            println("Hello")
        }
        //Запустится только после завершения всех сопрограмм в блоке coroutineScope.
        launch {
            println("launch 4th coroutine")
            println("finish 4th coroutine")
        }
        val fifthCoroutineJob: Job = launch {
            println("launch 5th coroutine")
            delay(timeMillis = 10000)
            println("finish 5th coroutine")
        }
        //явно ожидаем завершения 5th coroutine
        fifthCoroutineJob.join()
        launch {
            println("launch 6th coroutine")
            println("finish 6th coroutine")
        }
    }
    //Выполнится только после runBlocking
    println("End")
}

/**
 * Приостанавливаемая, прерываемая функция.
 */
suspend fun suspendFun() {
    delay(timeMillis = 1500)
    println("invoke Suspend function")
}