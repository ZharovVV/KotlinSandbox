package com.github.zharovvv.coroutines.lesson1

import com.github.zharovvv.coroutines.customLaunch
import kotlinx.coroutines.*
import kotlin.coroutines.Continuation

/**
 * # Coroutines (Сопрограммы)
 * __Сопрограмма__ — это экземпляр приостанавливаемых вычислений.
 * Концептуально он похож на поток в том смысле, что для запуска требуется блок кода,
 * который работает одновременно с остальным кодом.
 * Однако сопрограмма не привязана ни к какому конкретному потоку.
 * Он может приостановить выполнение в одном потоке и возобновить его в другом.
 *
 * Сопрограммы можно рассматривать как __легковесные потоки__,
 * но есть ряд важных отличий, которые сильно отличают их реальное использование от потоков.
 *
 * В первую очередь, __потоки__ применяются для организации __многозадачности__, __корутины__ же предоставляют
 * лишь __асинхронные операции__, но не выполняются параллельно (хоть в Kotlin JVM это возможно параллельность
 * не является частью понятия корутин).
 *
 * #
 * ## Преимущество корутин над потоками:
 * * легкость переключения между потоками (т.к. не нужно никаких системных вызов или каких-либо блокирующих
 * операций). Поэтому их называют __легковесными потоками__.
 * * Не требуют никакой поддержки со стороны ОС (позволяет легко добавить их в любой язык программирования).
 *
 * #
 * ## Асинхронность vs Параллельность
 * __Асинхронность__ - концепция праграммирования, в которой события происходят независимо от главного потока и
 * способ взаимодействия не является последовательным, а происходит через колбеки.
 * (Яркий пример mainThread в Android с Handler-ом и Looper-ом)
 * __Параллельность__ - тип вычислений, когда множество операций выполняется одновременно.
 * Современные процессоры способствуют этому т.к. имеют множество ядер.
 *
 * #
 * ## Корутины в Kotlin
 * Киллер фичей была возможность писать асинхронный код в синхронном стиле.
 *
 * Для поддержки корутин в котлине было добавлено одно ключевое слово __suspend__ _(рус. приостанавить)_
 * ```kotlin
 *  suspend fun doWork() {
 *      // Здесь будет долгая работа
 *  }
 * ```
 *
 * ```java
 *  //decompiled
 *  public final Object doWork(@NotNull Continuation<Unit> $completion)
 * ```
 *
 * Такая функция не может быть вызвана из обычной функции, т.к. она возвращает свой ответ асинхронно.
 * Suspend-функцию можно вызвать из другой suspend-функции, либо из корутины, которая создается из
 * корутин-билдеров.
 *
 * [Continuation] можно рассматривать как callback, который будет вызван по окончании выполнения
 * тела функции.
 *
 * Kotlin-копилятор преобразует весь код корутин (suspend-лямбд если быть точнее) в state-машину -
 * длинный цикл(??) switch-case, где каждый case соответствует какому-то вызову suspend-функции.
 * (Во что компилируется можно посмотреть тут [customLaunch])
 * Такой подход позволяет генерировать меньше кода и классов, а самое главное - создавать меньше объектов
 * в памяти во время работы приложения.
 *
 * В стандартную библиотеку Kotlin были добавлены лишь самые основные функции для организации работы корутин.
 * Все основные возможности корутин были добавлены через отдельную бибилиотеку __kotlinx.coroutines__.
 *
 * #
 * ## Coroutines vs Threads
 * Корутины используют только заданные пулы потоков. И используют их умно.
 * Ключевое слово suspend приостанавливает работу корутины, продолжение работы корутины может произойти на
 * любом потоке из [CoroutineDispatcher]-а, заданного в рамках этой корутины.
 *
 * __Корутина может выполняться в нескольких потоках.__
 * В примере ниже нет гарантии работы в одном потоке.
 * ```kotlin
 * val lock = ...
 * lock.lock() //захват блокировки
 * doSomething() //suspend функция
 * lock.unlock() //снятие блокировки
 * ```
 * Не стоит использовать апи синхронизации в корутинах.
 *
 * __Каждая корутина привязана к времени жизни [CoroutineScope].__
 * Любая запускаемая корутна привязана к [CoroutineScope], который и описывает этот некий жизненный цикл.
 *
 * __Состояние корутины (например isActive) проверяется перед тем, как продолжить её выполнение
 * после прерывания. Т.е. перед вызовом любой suspend функции корутина может быть остановлена.__
 *
 * #
 * ## Примеры некоторых функций
 *
 * * [launch] - это builder сопрограмм.
 * Он запускает новую сопрограмму одновременно с остальным кодом, которая продолжает работать независимо.
 *
 * * [delay] - это специальная функция приостановки.
 * Он приостанавливает сопрограмму на определенное время.
 * Приостановка сопрограммы не блокирует базовый поток, но позволяет запускать другие сопрограммы
 * и использовать базовый поток для своего кода.
 *
 * * [runBlocking] - также является builder-ом сопрограмм,
 * который соединяет между собой обычный мир без сопрограмм _fun main()_
 * и код с сопрограммами внутри _runBlocking { ... }_ фигурных скобок.
 * Это выделяется в IDE _this: CoroutineScope_ подсказкой сразу после runBlocking открывающей фигурной скобки.
 * Если вы удалите или забудете runBlocking в этом коде, вы получите ошибку при вызове запуска launch,
 * так как он объявлен только в CoroutineScope :
 * ```
 * Unresolved reference: launch
 * ```
 * Название runBlocking означает, что выполняющий его поток (в данном случае — основной поток)
 * блокируется на время вызова, пока все сопрограммы внутри runBlocking { ... } не завершат свое выполнение.
 * Вы часто будете видеть runBlocking такое использование на самом верхнем уровне приложения
 * и довольно редко внутри реального кода, поскольку потоки являются дорогостоящими ресурсами,
 * и их блокировка неэффективна и часто нежелательна.
 *
 * ##
 * ## Структурированный параллелизм (Structured concurrency)
 * Сопрограммы следуют принципу структурированного параллелизма,
 * что означает, что новые сопрограммы могут запускаться только в определенной CoroutineScope,
 * которая ограничивает время жизни сопрограммы.
 * В приведенном выше примере показано, что runBlocking устанавливает соответствующую область действия,
 * и поэтому предыдущий пример ждет, пока World! не будет напечатано после секундной задержки,
 * и только после этого завершается.
 *
 * В реальном приложении вы будете запускать множество сопрограмм.
 * Структурированный параллелизм гарантирует, что они не будут потеряны и не будут утечек.
 * Внешняя область не может завершиться, пока не будут завершены все ее дочерние сопрограммы.
 * Структурированный параллелизм также гарантирует, что обо всех ошибках в коде сообщается должным образом,
 * и они никогда не теряются.
 */
fun main() {
    //Блокирует текущий поток (до тех пор пока все сопрограммы внутри блока runBlocking не будут выполнены)
    runBlocking {
        val runBlockingCoroutineScope = this
        //val coroutineScope: CoroutineScope = this
        launch { //is the same coroutineScope.launch {...}
            val coroutineScope = this
            println("launch 1st coroutine")
            delay(timeMillis = 1000)
            println("World!")
            println("finish 1st coroutine")
        }
        launch {
            println("launch 2nd coroutine")
            suspendFun()
            println("finish 2nd coroutine")
        }
        //
        coroutineScope {
            launch {
                println("launch 3rd coroutine")
                delay(timeMillis = 800)
                println("invoke CoroutineScope")
                println("finish 3rd coroutine")
            }
            println("Hello")
        }
        //Запустится только после завершения всех сопрограмм в блоке coroutineScope.
        launch {
            println("launch 4th coroutine")
            println("finish 4th coroutine")
        }
        val fifthCoroutineJob: Job = launch {
            println("launch 5th coroutine")
            delay(timeMillis = 10000)
            println("finish 5th coroutine")
        }
        //явно ожидаем завершения 5th coroutine
        fifthCoroutineJob.join()
        launch {
            println("launch 6th coroutine")
            println("finish 6th coroutine")
        }
    }
    //Выполнится только после runBlocking
    println("End")
}

/**
 * Приостанавливаемая, прерываемая функция.
 */
suspend fun suspendFun() {
    delay(timeMillis = 1500)
    println("invoke Suspend function")
}