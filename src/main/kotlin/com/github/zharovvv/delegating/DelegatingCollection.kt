package com.github.zharovvv.delegating

/**
 * # Делегирование в классах
 *
 * Часто бывает нужно добавить поведение в другой класс, даже если он не предназначен для наследованияю
 * Для этого применяется шаблон "Декоратор". Он создает новый класс с тем же итерфейсом, что у оригинального класса,
 * и сохраняет экземпляр оригинального класса в поле нового класса. Методы, поведение которых должно остаться неизменным,
 * просто передают вызовы оригинальному экземпляру класса.
 * Недостаток такого подхода - большой объем шаблонного кода.
 *
 * При использованиии Kotlin писать много шабллонного кода не нужно, так как он предаставляет полноценную поддержку
 * **делегирования** на уровне языка. Всякий раз, реализуя интерфейс, вы можете _делегировать_ реализацию другому объекту,
 * добавив ключевое слово by.
 */
class DelegatingCollection<T>(
    private val innerList: Collection<T> = ArrayList()
) : Collection<T> by innerList {

    override val size: Int
        get() {
            //Additional logic
            return innerList.size
        }

    //Остальные методы Collection делегируются объекту innerList (по умолчанию ArrayList)
}