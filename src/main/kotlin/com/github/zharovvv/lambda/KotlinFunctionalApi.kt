package com.github.zharovvv.lambda

data class Person(val name: String, val age: Int) {

}

fun main() {
    val persons = listOf(
        Person("John", 21),
        Person("Sara", 24),
        Person("Yuliy", 24)
    )

    val maxAge = persons.maxByOrNull(Person::age)?.age
    val name: String? = persons
        .find { person -> person.age == maxAge }
        ?.name
    println(name)

    val groupedList: Map<Int, List<Person>> = persons.groupBy { it.age }
    print(groupedList)

    val strings = listOf("abc", "def")
    /**
     * Функция flatMap сначала преобразует (отображает map) каждый элемент
     * в коллекцию, согласно функции, переданной в аргументе, а затем собирает (или уплощает flattens)
     * несколько коллекций в одну.
     *
     * Все основные функции-расширения над коллекциями объявлены встраиваемыми (inline).
     * То есть тела этих функций будут встроены в конечный код без создания дополнительных (анонимных) классов.
     * Однако цепочки таких вызовов каждый раз будут создавать промежуточную коллекцию, где будет храниться результат
     * очередной операции над коллекцией. Если число обрабатываемых элементов велико и накладные расходы на создание
     * промежуточной коллекции становятся слишком ощутимыми, можно воспользоваться последовательностью [Sequence].
     * Однако в этом случае лямбда-выражения не будут встраиваться.
     *
     * Поэтому, хотя операции в последовательности откладываются, вы не должны стремиться вставлять [asSequence] в
     * каждую цепочку опреаций с коллекциями в своём коде. Этот прием дает преимущество только при работе с большими
     * коллекциями, а мальнькие коллекции можно обрабатывать как обычно.
     */
    println(strings.flatMap { string -> string.toList() })

    /**
     * При использовании Последовательностей (Sequences) не создается промежуточных коллекций для хранения элементов,
     * а следовательно, для большого количества элементов производительность будет заметно лучше.
     *
     * Точка входа для выполнения отложенных операций в Kotlin - интерфейс Sequence.
     * Он представляет собой простую последовательность элементов, которые могут перечисляться один за другим.
     * Интерфейс Sequence определяет только один метод - iterator,
     * который используется для получения значений последовательности.
     *
     * Особенность интерфейса Sequence - способ реализации операций. Элементы последовательности вычисляются «лениво».
     *
     * Любую коллекцию можно преобразовать в последовательность, вызвав функцию-расширение asSequence.
     * Обратное преобразование выполняется вызовом функции toList.
     */
    val personName: List<String> = persons.asSequence()
        .map { person -> person.name }
        .filter { personName -> personName.startsWith("j", ignoreCase = true) }
        .toList()

}